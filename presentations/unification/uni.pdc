---
title: unification

theme: night
header-includes: <link rel=stylesheet href=style-extra.css>
history: true

bibliography: uni.bib
citation-style: apa-single-spaced
...


# what is unification?

:::squish
(from @dcpl [pp. 781â€“787]) \
(or TAPL (pp. 327â€“329)) \
(or any other textbook, wikipedia, etc)
:::

:::notes
- @dcpl = "design concepts in programming languages"
- the description in tapl is fine just a little less detailed
:::


## substitutions

:::defs
$$
\newcommand\T\mathbf
$$
:::

- a *metavariable* $Î±, Î², \dotsc$ is a hole in a type
  to be filled in by unification

- a *substitution* $Ïƒ, Î¸$ is a map from metavariables to types, e.g.
  $\{ Î± \mapsto \T{Nat}, Î² \mapsto (\T{List} \: Î³ \to \T{Bool}) \}$

- applying the substitution $Ïƒ$ to $A$ is written $A\,Ïƒ$

- substitutions can be composed $Ïƒ;Î¸$ \
  $A(Ïƒ;Î¸) = (A\,Ïƒ)Î¸$

:::notes
- a metavariable is any variable made up by the compiler really
- contrasting with variables from the actual program
- these are more properly "unification variables"
- .
- the types can also contain holes
- .
- it's also written a lot of other ways admittedly.
  $A[Ïƒ]$, $Ïƒ\,A$, $Ïƒ(A)$, ...
- .
- composition $Ïƒ;Î¸$ is like do $Ïƒ$ first, then $Î¸$ on the result
- if you apply composition prefix like $Ïƒ\,A$ then you probably write
  composition like $Î¸âˆ˜Ïƒ$ (with the substs the other way round) too
:::


## unification problems

- a unification problem $P$ is a set of wanted equations
  $A \doteq B$ between types containing metavariables

- the goal of unification is to produce a single substitution $Ïƒ$
  (a *unifier*) where
  $A_i\,Ïƒ = B_i\,Ïƒ$ for each equation $A_i \doteq B_i$
  in the original problem

:::notes
- for some suitable definition of "="
- we want $Î±Î²Î·$ obviously. so we'll do unification on normalised terms
:::


## most general unifiers

- there's likely more than one unifier for a problem
  - $\{\T{List} \: Î± \doteq \T{List} \: Î²\}$ is solved by
    $Ïƒ = \{Î± \mapsto Î²\}$ but also
    $Î¸ = \{Î± \mapsto \T{Nat}, Î² \mapsto \T{Nat}\}$, ...

- a *most general unifier* or mgu for $P$ is a $Ïƒ$ where
  - for any **other** unifier $Î¸$ for $P$,
  - $Î¸$ is equal to $(Ïƒ;Î¸')$ for some $Î¸'$

- in this example, $Î¸ = Ïƒ; \{Î² \mapsto \T{Nat}\}$

:::notes
- mgus are unique **up to renaming of metas** as well as regular $Î±$
- basically an mgu is a unifier that doesn't make any arbitrary decisions
:::


# what's unification for anyway?

## implicit arguments

:::defs
$$
\newcommand\F{\mathsf}
$$
:::

:::incremental
- $\F{const} \: \T{true} : \T{Nat} \to \_$ \
  [($\F{const} : \{A, B : \star\} \to A \to B \to A$)]{.squish}

- $\F{const} \: \{A=Î±, B=Î²\} \: \T{true} : \T{Nat} \to Î³$ \
  [($\F{const} \: \{A=Î±, B=Î²\} : Î± \to Î² \to Î±$)]{.squish}

- $\{Î± \doteq \T{Bool}, (Î² \to Î±) \doteq (\T{Nat} \to Î³)\}$

- :sparkles: :sparkles: :sparkles: :sparkles:

- $\{Î± \mapsto \T{Bool}, Î² \mapsto \T{Nat}, Î³ \mapsto \T{Bool}\}$

- $\F{const} \: \{A=\T{Bool}, B=\T{Nat}\} \: \T{true} : \T{Nat} \to \T{Bool}$
:::

:::notes
(in this case we also want the solution to have no metas left over)

1. we want to fill in the implicits for `const true` in a context where it's
   type is expected to be `Nat -> _` (where `_` is unknown yet)
2. fill in the implicit arguments and `_`s with a fresh meta each
3. match up the types of the given argument with the type of const after step 1
4. some magic happens...
5. ...and we end up with a substitution...
6. ...which we can use to fill in the metas in the original term
:::


## coverage checking

:::defs
$$
\newcommand\K{\mathtt}
$$
:::

easier to describe interactively

[:page_facing_up: so.idr](so.idr)


:::notes
- `So b` is only inhabited when `b` is defined
  so it's a way to enforce preconditions
  - [uncomment `bad`, `\r`, get a type error]
  - [`\a` on safeDiv; `\t` on rhs]
- to make the type of `prf` reduce we have to match on `y /= 0`
  - [`\w`, fill with `y /= 0`, rename `with_pat` to `y_not_0`, `\t` on rhs]
- now the argument to `So` is just a variable so we can match on it
  - [`\c` on `y_not_0`, `\t` on `False` case's rhs]
- `prf` has type `So False` here
  - idris tries to unify `So False` with the result of all of `So`'s
    constructors. in this case just `Oh`. and it gets a definite failure
  - so we can delete this clause entirely and the function is still accepted as
    total [delete it, `\r`]
  - now we only have a situation where the precondition is satisfied
    and we can match on the proof \
    [`\c` on `prf`] \
    and call ``x `div` y`` \
    [fill it in, `\r`]
:::


## dependent pattern matching

[:page_facing_up: vec.idr](vec.idr)

:::notes
- a `Vec` is a list with its length in its type
- a `Fin n` represents the natural numbers less than `n`
  - `Z` is an element of any `Fin` at least 1
  - `S` takes an element of the previous set
  - so each one has one more element than the last
- since their sizes line up, we can use `Fin n` to index into a `Vec n a`
- `n` is usually implicit, but i made it visible here to see what happens to it.
  also, look, a usage
- [`\c` on `i`, rename `x` to `i`] \
  when you match on the fin, the return index of each constructor is unified
  with `n`. in both cases you get an `S` so the first argument also changes
- [`\t` on first rhs] \
  this has also changed the type of `xs`, since it contained `n`.
  now the only possible pattern is `(::)` \
  [`\c` on each `xs`]
- so you'll never fall off the end of the list
:::



# in summary

-----

- we want an algorithm that can take any two juvix terms with holes
  and find an mgu for them if one exists

. . .

- @undecidable :speech_balloon: you can't lol

- ok, in that case we want to carve out a sublanguage where we **do** have
  that. what are our options

:::notes
- @undecidable says specifically that unification of formulas of
  second- (or higher-)order logic is undecidable
- (second order logic is where you can have function variables)
- so this means that Î» term unification also is, if we allow
  metavariables to have arguments
:::

-----

:::incremental
- first-order unification

- static pattern unification

- :star:dynamic:star: pattern unification
:::

:::notes
- first order unification is easy
- static pat unification is... also pretty easy
- dynamic pat unification is where it gets hard
:::


# first-order unification

## first-order variables

- metavariables cannot be applied to arguments

- âœ“ $\T{List} \: Î± \quad Î± \to \T{Bool} \quad (x : Î±) \to Î² \to P \: x$
  - (but $Î²$'s solution won't contain $x$)

- âœ— $Î± \: \T{Int} \quad (x : â„•) \to Î² \: x$

-----

## example

:::defs
$$
\newcommand\OR{\mathrel|}
$$
:::

the types of STLC with naturals, booleans, and lists

$$
S,T \Coloneqq \T{Nat} \OR \T{Bool} \OR \T{List}\:T \OR S \to T \OR Î±
$$

:::squish
[:page_facing_up: firstorder.hs](firstorder.hs) \
algorithm taken from @dcpl
:::

:::notes
- TAPL has a unification algorithm on p.327
- but i found the way it's presented here a little clearer
- the example before was
  $$\{Î± \doteq \T{Bool}, (Î² \to Î±) \doteq (\T{Nat} \to Î³)\}$$
:::


## complexity

- pure implementation is $\mathcal{O}(n^2)$: \
  `â€¦ = unifyLoop (ğ’ƒğ’Šğ’ğ’… Î± b Ïƒ) (ğ’ğ’”ğ’–ğ’ƒğ’”ğ’•ğ‘·ğ’“ğ’ğ’ƒğ’” Î± b ps)`

- `ST` based implementation that updates metas in-place
  is $\mathcal{O}(n)$

:::notes
- `bind` traverses the solution so far to substitute occurrences of `Î±`
- same with `msubstProbs` and the outstanding problems
- both are linear in data bounded by the input,
  so overall the algorithm is quadratic
:::


# pattern unification

## patterns

- a *pattern* is a term $t$ in normal form,
  where all metavariables are heads of applications to spines of
  **distinct** possibly-$Î·$-expanded bound variables [@nipkow]

- âœ“ $C \: Î± \: Î² \: Î³ \quad
     Î»x. C \: x \quad
     Î»x. Î± \: (Î»z. x \: z) \quad
     Î»x \, y. Î± \: y \: x$

- âœ— $Î± \: C \quad
     Î»x. Î± \: x \: x \quad
     Î»x. Î± \: (Î± \: x)$

:::notes
- $C$ is a constructor
- examples:
  1. first-order exprs are patterns because the metas
     aren't applied to anything at all
  2. no metas no problem
  3. innermost thing is $Î·$-expansion of $x$
  4. order unimportant
- non-examples:
  1. applied to a constructor
  2. non-distinct
  3. not a variable
- if record types have $Î·$ (and they probably will)
  then projections are also patterns,
  and a record is $Î·$-equivalent to its projections,
  so then a record is a pattern if all its fields are
:::


## static or dynamic

- *static* pattern unification [@nipkow] fails immediately
  if any of the problems are not first-order or a pattern

- *dynamic* pattern unification [@tut] instead marks that
  problem as blocked, because it may be possible to solve
  it later e.g. when some other variables have been solved

. . .

- $Î± \: x \: x \doteq Î² \: x$ can't be solved right away
- but if later $Î² \mapsto Î»\,\_. C$, \
  $Î± \: x \: x \doteq C$ can be also be solved \
  with $Î± \mapsto Î»\,\_\,\_. C$

:::notes
- this example works because dpu also prunes the
  bound variables which do not occur in both sides,
  so the nonlinearity of $Î±$ is removed
:::

## static

<img src=spu.svg width=100%>

## example (static)

$$
s, t, A, B \Coloneqq Î± \OR x \OR Î»x. t \OR s \: t
           \OR (s, t) \OR \T{fst} \: s \OR \T{snd} \: s
$$

:::squish
[:page_facing_up: staticpattern.hs](staticpattern.hs) \
algorithm taken from @nipkow
:::

## dynamic

- it's very complicated
- please read @tut, sorry
  - and the erratum!!!
- but the actual unification algorithm is the same
- adds a queue of blocked problems, bound variable pruning,
  some infrastructure to ensure it produces well-typed solutions

# conclusion

-----

- unification is actually not as hard as you might think

- unless you do dynamic pattern unification, then it's harder

- but we can work our way up gradually

- and work from the actual haskell source code that they provide


## references
