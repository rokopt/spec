<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>unification</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/night.css" id="theme">
  <link rel=stylesheet href=style-extra.css>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">unification</h1>
</section>

<section>
<section id="what-is-unification" class="title-slide slide level1">
<h1>what is unification?</h1>
<div class="squish">
<p>(from <span class="citation" data-cites="dcpl">Turbak &amp; Gifford (2008, pp. 781‚Äì787)</span>)<br />
(or TAPL (pp.¬†327‚Äì329))<br />
(or any other textbook, wikipedia, etc)</p>
</div>
<aside class="notes">
<ul>
<li><span class="citation" data-cites="dcpl">Turbak &amp; Gifford (2008)</span> = ‚Äúdesign concepts in programming languages‚Äù</li>
<li>the description in tapl is fine just a little less detailed</li>
</ul>
</aside>
</section>
<section id="substitutions" class="slide level2">
<h2>substitutions</h2>
<div class="defs">
<p><span class="math display">\[
\newcommand\T\mathbf
\]</span></p>
</div>
<ul>
<li><p>a <em>metavariable</em> <span class="math inline">\(Œ±, Œ≤, \dotsc\)</span> is a hole in a type to be filled in by unification</p></li>
<li><p>a <em>substitution</em> <span class="math inline">\(œÉ, Œ∏\)</span> is a map from metavariables to types, e.g. <span class="math inline">\(\{ Œ± \mapsto \T{Nat}, Œ≤ \mapsto (\T{List} \: Œ≥ \to \T{Bool}) \}\)</span></p></li>
<li><p>applying the substitution <span class="math inline">\(œÉ\)</span> to <span class="math inline">\(A\)</span> is written <span class="math inline">\(A\,œÉ\)</span></p></li>
<li><p>substitutions can be composed <span class="math inline">\(œÉ;Œ∏\)</span><br />
<span class="math inline">\(A(œÉ;Œ∏) = (A\,œÉ)Œ∏\)</span></p></li>
</ul>
<aside class="notes">
<ul>
<li>a metavariable is any variable made up by the compiler really</li>
<li>contrasting with variables from the actual program</li>
<li>these are more properly ‚Äúunification variables‚Äù</li>
<li>.</li>
<li>the types can also contain holes</li>
<li>.</li>
<li>it‚Äôs also written a lot of other ways admittedly. <span class="math inline">\(A[œÉ]\)</span>, <span class="math inline">\(œÉ\,A\)</span>, <span class="math inline">\(œÉ(A)\)</span>, ‚Ä¶</li>
<li>.</li>
<li>composition <span class="math inline">\(œÉ;Œ∏\)</span> is like do <span class="math inline">\(œÉ\)</span> first, then <span class="math inline">\(Œ∏\)</span> on the result</li>
<li>if you apply composition prefix like <span class="math inline">\(œÉ\,A\)</span> then you probably write composition like <span class="math inline">\(Œ∏‚àòœÉ\)</span> (with the substs the other way round) too</li>
</ul>
</aside>
</section>
<section id="unification-problems" class="slide level2">
<h2>unification problems</h2>
<ul>
<li><p>a unification problem <span class="math inline">\(P\)</span> is a set of wanted equations <span class="math inline">\(A \doteq B\)</span> between types containing metavariables</p></li>
<li><p>the goal of unification is to produce a single substitution <span class="math inline">\(œÉ\)</span> (a <em>unifier</em>) where <span class="math inline">\(A_i\,œÉ = B_i\,œÉ\)</span> for each equation <span class="math inline">\(A_i \doteq B_i\)</span> in the original problem</p></li>
</ul>
<aside class="notes">
<ul>
<li>for some suitable definition of ‚Äú=‚Äù</li>
<li>we want <span class="math inline">\(Œ±Œ≤Œ∑\)</span> obviously. so we‚Äôll do unification on normalised terms</li>
</ul>
</aside>
</section>
<section id="most-general-unifiers" class="slide level2">
<h2>most general unifiers</h2>
<ul>
<li>there‚Äôs likely more than one unifier for a problem
<ul>
<li><span class="math inline">\(\{\T{List} \: Œ± \doteq \T{List} \: Œ≤\}\)</span> is solved by <span class="math inline">\(œÉ = \{Œ± \mapsto Œ≤\}\)</span> but also <span class="math inline">\(Œ∏ = \{Œ± \mapsto \T{Nat}, Œ≤ \mapsto \T{Nat}\}\)</span>, ‚Ä¶</li>
</ul></li>
<li>a <em>most general unifier</em> or mgu for <span class="math inline">\(P\)</span> is a <span class="math inline">\(œÉ\)</span> where
<ul>
<li>for any <strong>other</strong> unifier <span class="math inline">\(Œ∏\)</span> for <span class="math inline">\(P\)</span>,</li>
<li><span class="math inline">\(Œ∏\)</span> is equal to <span class="math inline">\((œÉ;Œ∏&#39;)\)</span> for some <span class="math inline">\(Œ∏&#39;\)</span></li>
</ul></li>
<li>in this example, <span class="math inline">\(Œ∏ = œÉ; \{Œ≤ \mapsto \T{Nat}\}\)</span></li>
</ul>
<aside class="notes">
<ul>
<li>mgus are unique <strong>up to renaming of metas</strong> as well as regular <span class="math inline">\(Œ±\)</span></li>
<li>basically an mgu is a unifier that doesn‚Äôt make any arbitrary decisions</li>
</ul>
</aside>
</section></section>
<section>
<section id="whats-unification-for-anyway" class="title-slide slide level1">
<h1>what‚Äôs unification for anyway?</h1>

</section>
<section id="implicit-arguments" class="slide level2">
<h2>implicit arguments</h2>
<div class="defs">
<p><span class="math display">\[
\newcommand\F{\mathsf}
\]</span></p>
</div>
<div>
<ul>
<li class="fragment"><p><span class="math inline">\(\F{const} \: \T{true} : \T{Nat} \to \_\)</span><br />
<span class="squish">(<span class="math inline">\(\F{const} : \{A, B : \star\} \to A \to B \to A\)</span>)</span></p></li>
<li class="fragment"><p><span class="math inline">\(\F{const} \: \{A=Œ±, B=Œ≤\} \: \T{true} : \T{Nat} \to Œ≥\)</span><br />
<span class="squish">(<span class="math inline">\(\F{const} \: \{A=Œ±, B=Œ≤\} : Œ± \to Œ≤ \to Œ±\)</span>)</span></p></li>
<li class="fragment"><p><span class="math inline">\(\{Œ± \doteq \T{Bool}, (Œ≤ \to Œ±) \doteq (\T{Nat} \to Œ≥)\}\)</span></p></li>
<li class="fragment"><p><span class="emoji" data-emoji="sparkles">‚ú®</span> <span class="emoji" data-emoji="sparkles">‚ú®</span> <span class="emoji" data-emoji="sparkles">‚ú®</span> <span class="emoji" data-emoji="sparkles">‚ú®</span></p></li>
<li class="fragment"><p><span class="math inline">\(\{Œ± \mapsto \T{Bool}, Œ≤ \mapsto \T{Nat}, Œ≥ \mapsto \T{Bool}\}\)</span></p></li>
<li class="fragment"><p><span class="math inline">\(\F{const} \: \{A=\T{Bool}, B=\T{Nat}\} \: \T{true} : \T{Nat} \to \T{Bool}\)</span></p></li>
</ul>
</div>
<aside class="notes">
<p>(in this case we also want the solution to have no metas left over)</p>
<ol type="1">
<li>we want to fill in the implicits for <code>const true</code> in a context where it‚Äôs type is expected to be <code>Nat -&gt; _</code> (where <code>_</code> is unknown yet)</li>
<li>fill in the implicit arguments and <code>_</code>s with a fresh meta each</li>
<li>match up the types of the given argument with the type of const after step 1</li>
<li>some magic happens‚Ä¶</li>
<li>‚Ä¶and we end up with a substitution‚Ä¶</li>
<li>‚Ä¶which we can use to fill in the metas in the original term</li>
</ol>
</aside>
</section>
<section id="coverage-checking" class="slide level2">
<h2>coverage checking</h2>
<div class="defs">
<p><span class="math display">\[
\newcommand\K{\mathtt}
\]</span></p>
</div>
<p>easier to describe interactively</p>
<p><a href="so.idr"><span class="emoji" data-emoji="page_facing_up">üìÑ</span> so.idr</a></p>
<aside class="notes">
<ul>
<li><code>So b</code> is only inhabited when <code>b</code> is defined so it‚Äôs a way to enforce preconditions
<ul>
<li>[uncomment <code>bad</code>, <code>\r</code>, get a type error]</li>
<li>[<code>\a</code> on safeDiv; <code>\t</code> on rhs]</li>
</ul></li>
<li>to make the type of <code>prf</code> reduce we have to match on <code>y /= 0</code>
<ul>
<li>[<code>\w</code>, fill with <code>y /= 0</code>, rename <code>with_pat</code> to <code>y_not_0</code>, <code>\t</code> on rhs]</li>
</ul></li>
<li>now the argument to <code>So</code> is just a variable so we can match on it
<ul>
<li>[<code>\c</code> on <code>y_not_0</code>, <code>\t</code> on <code>False</code> case‚Äôs rhs]</li>
</ul></li>
<li><code>prf</code> has type <code>So False</code> here
<ul>
<li>idris tries to unify <code>So False</code> with the result of all of <code>So</code>‚Äôs constructors. in this case just <code>Oh</code>. and it gets a definite failure</li>
<li>so we can delete this clause entirely and the function is still accepted as total [delete it, <code>\r</code>]</li>
<li>now we only have a situation where the precondition is satisfied and we can match on the proof<br />
[<code>\c</code> on <code>prf</code>]<br />
and call <code>x `div` y</code><br />
[fill it in, <code>\r</code>]</li>
</ul></li>
</ul>
</aside>
</section>
<section id="dependent-pattern-matching" class="slide level2">
<h2>dependent pattern matching</h2>
<p><a href="vec.idr"><span class="emoji" data-emoji="page_facing_up">üìÑ</span> vec.idr</a></p>
<aside class="notes">
<ul>
<li>a <code>Vec</code> is a list with its length in its type</li>
<li>a <code>Fin n</code> represents the natural numbers less than <code>n</code>
<ul>
<li><code>Z</code> is an element of any <code>Fin</code> at least 1</li>
<li><code>S</code> takes an element of the previous set</li>
<li>so each one has one more element than the last</li>
</ul></li>
<li>since their sizes line up, we can use <code>Fin n</code> to index into a <code>Vec n a</code></li>
<li><code>n</code> is usually implicit, but i made it visible here to see what happens to it. also, look, a usage</li>
<li>[<code>\c</code> on <code>i</code>, rename <code>x</code> to <code>i</code>]<br />
when you match on the fin, the return index of each constructor is unified with <code>n</code>. in both cases you get an <code>S</code> so the first argument also changes</li>
<li>[<code>\t</code> on first rhs]<br />
this has also changed the type of <code>xs</code>, since it contained <code>n</code>. now the only possible pattern is <code>(::)</code><br />
[<code>\c</code> on each <code>xs</code>]</li>
<li>so you‚Äôll never fall off the end of the list</li>
</ul>
</aside>
</section></section>
<section>
<section id="in-summary" class="title-slide slide level1">
<h1>in summary</h1>

</section>
<section class="slide level2">

<ul>
<li>we want an algorithm that can take any two juvix terms with holes and find an mgu for them if one exists</li>
</ul>
<div class="fragment">
<ul>
<li><p><span class="citation" data-cites="undecidable">Goldfarb (1981)</span> <span class="emoji" data-emoji="speech_balloon">üí¨</span> you can‚Äôt lol</p></li>
<li><p>ok, in that case we want to carve out a sublanguage where we <strong>do</strong> have that. what are our options</p></li>
</ul>
<aside class="notes">
<ul>
<li><span class="citation" data-cites="undecidable">Goldfarb (1981)</span> says specifically that unification of formulas of second- (or higher-)order logic is undecidable</li>
<li>(second order logic is where you can have function variables)</li>
<li>so this means that Œª term unification also is, if we allow metavariables to have arguments</li>
</ul>
</aside>
</div>
</section>
<section class="slide level2">

<div>
<ul>
<li class="fragment"><p>first-order unification</p></li>
<li class="fragment"><p>static pattern unification</p></li>
<li class="fragment"><p><span class="emoji" data-emoji="star">‚≠ê</span>dynamic<span class="emoji" data-emoji="star">‚≠ê</span> pattern unification</p></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>first order unification is easy</li>
<li>static pat unification is‚Ä¶ also pretty easy</li>
<li>dynamic pat unification is where it gets hard</li>
</ul>
</aside>
</section></section>
<section>
<section id="first-order-unification" class="title-slide slide level1">
<h1>first-order unification</h1>

</section>
<section id="first-order-variables" class="slide level2">
<h2>first-order variables</h2>
<ul>
<li><p>metavariables cannot be applied to arguments</p></li>
<li><p>‚úì <span class="math inline">\(\T{List} \: Œ± \quad Œ± \to \T{Bool} \quad (x : Œ±) \to Œ≤ \to P \: x\)</span></p>
<ul>
<li>(but <span class="math inline">\(Œ≤\)</span>‚Äôs solution won‚Äôt contain <span class="math inline">\(x\)</span>)</li>
</ul></li>
<li><p>‚úó <span class="math inline">\(Œ± \: \T{Int} \quad (x : ‚Ñï) \to Œ≤ \: x\)</span></p></li>
</ul>
</section>
<section id="example" class="slide level2">
<h2>example</h2>
<div class="defs">
<p><span class="math display">\[
\newcommand\OR{\mathrel|}
\]</span></p>
</div>
<p>the types of STLC with naturals, booleans, and lists</p>
<p><span class="math display">\[
S,T \Coloneqq \T{Nat} \OR \T{Bool} \OR \T{List}\:T \OR S \to T \OR Œ±
\]</span></p>
<div class="squish">
<p><a href="firstorder.hs"><span class="emoji" data-emoji="page_facing_up">üìÑ</span> firstorder.hs</a><br />
algorithm taken from <span class="citation" data-cites="dcpl">Turbak &amp; Gifford (2008)</span></p>
</div>
<aside class="notes">
<ul>
<li>TAPL has a unification algorithm on p.327</li>
<li>but i found the way it‚Äôs presented here a little clearer</li>
<li>the example before was <span class="math display">\[\{Œ± \doteq \T{Bool}, (Œ≤ \to Œ±) \doteq (\T{Nat} \to Œ≥)\}\]</span></li>
</ul>
</aside>
</section>
<section id="complexity" class="slide level2">
<h2>complexity</h2>
<ul>
<li><p>pure implementation is <span class="math inline">\(\mathcal{O}(n^2)\)</span>:<br />
<code>‚Ä¶ = unifyLoop (<u>bind</u> Œ± b œÉ) (<u>substProbs</u> Œ± b ps)</code></p></li>
<li><p><code>ST</code> based implementation that updates metas in-place is <span class="math inline">\(\mathcal{O}(n)\)</span></p></li>
</ul>
<aside class="notes">
<ul>
<li><code>bind</code> traverses the solution so far to substitute occurrences of <code>Œ±</code></li>
<li>same with <code>msubstProbs</code> and the outstanding problems</li>
<li>both are linear in data bounded by the input, so overall the algorithm is quadratic</li>
</ul>
</aside>
</section></section>
<section>
<section id="pattern-unification" class="title-slide slide level1">
<h1>pattern unification</h1>

</section>
<section id="patterns" class="slide level2">
<h2>patterns</h2>
<ul>
<li><p>a <em>pattern</em> is a term <span class="math inline">\(t\)</span> in normal form, where all metavariables are heads of applications to spines of <strong>distinct</strong> possibly-<span class="math inline">\(Œ∑\)</span>-expanded bound variables <span class="citation" data-cites="nipkow">(Nipkow, 1993)</span></p></li>
<li><p>‚úì <span class="math inline">\(C \: Œ± \: Œ≤ \: Œ≥ \quad  Œªx. C \: x \quad  Œªx. Œ± \: (Œªz. x \: z) \quad  Œªx \, y. Œ± \: y \: x\)</span></p></li>
<li><p>‚úó <span class="math inline">\(Œ± \: C \quad  Œªx. Œ± \: x \: x \quad  Œªx. Œ± \: (Œ± \: x)\)</span></p></li>
</ul>
<aside class="notes">
<ul>
<li><span class="math inline">\(C\)</span> is a constructor</li>
<li>examples:
<ol type="1">
<li>first-order exprs are patterns because the metas aren‚Äôt applied to anything at all</li>
<li>no metas no problem</li>
<li>innermost thing is <span class="math inline">\(Œ∑\)</span>-expansion of <span class="math inline">\(x\)</span></li>
<li>order unimportant</li>
</ol></li>
<li>non-examples:
<ol type="1">
<li>applied to a constructor</li>
<li>non-distinct</li>
<li>not a variable</li>
</ol></li>
<li>if record types have <span class="math inline">\(Œ∑\)</span> (and they probably will) then projections are also patterns, and a record is <span class="math inline">\(Œ∑\)</span>-equivalent to its projections, so then a record is a pattern if all its fields are</li>
</ul>
</aside>
</section>
<section id="static-or-dynamic" class="slide level2">
<h2>static or dynamic</h2>
<ul>
<li><p><em>static</em> pattern unification <span class="citation" data-cites="nipkow">(Nipkow, 1993)</span> fails immediately if any of the problems are not first-order or a pattern</p></li>
<li><p><em>dynamic</em> pattern unification <span class="citation" data-cites="tut">(Gundry &amp; McBride, 2013)</span> instead marks that problem as blocked, because it may be possible to solve it later e.g.¬†when some other variables have been solved</p></li>
</ul>
<div class="fragment">
<ul>
<li><span class="math inline">\(Œ± \: x \: x \doteq Œ≤ \: x\)</span> can‚Äôt be solved right away</li>
<li>but if later <span class="math inline">\(Œ≤ \mapsto Œª\,\_. C\)</span>,<br />
<span class="math inline">\(Œ± \: x \: x \doteq C\)</span> can be also be solved<br />
with <span class="math inline">\(Œ± \mapsto Œª\,\_\,\_. C\)</span></li>
</ul>
<aside class="notes">
<ul>
<li>this example works because dpu also prunes the bound variables which do not occur in both sides, so the nonlinearity of <span class="math inline">\(Œ±\)</span> is removed</li>
</ul>
</aside>
</div>
</section>
<section id="static" class="slide level2">
<h2>static</h2>
<p><img src=spu.svg width=100%></p>
</section>
<section id="example-static" class="slide level2">
<h2>example (static)</h2>
<p><span class="math display">\[
s, t, A, B \Coloneqq Œ± \OR x \OR Œªx. t \OR s \: t
           \OR (s, t) \OR \T{fst} \: s \OR \T{snd} \: s
\]</span></p>
<div class="squish">
<p><a href="staticpattern.hs"><span class="emoji" data-emoji="page_facing_up">üìÑ</span> staticpattern.hs</a><br />
algorithm taken from <span class="citation" data-cites="nipkow">Nipkow (1993)</span></p>
</div>
</section>
<section id="dynamic" class="slide level2">
<h2>dynamic</h2>
<ul>
<li>it‚Äôs very complicated</li>
<li>please read <span class="citation" data-cites="tut">Gundry &amp; McBride (2013)</span>, sorry
<ul>
<li>and the erratum!!!</li>
</ul></li>
<li>but the actual unification algorithm is the same</li>
<li>adds a queue of blocked problems, bound variable pruning, some infrastructure to ensure it produces well-typed solutions</li>
</ul>
</section></section>
<section>
<section id="conclusion" class="title-slide slide level1">
<h1>conclusion</h1>

</section>
<section class="slide level2">

<ul>
<li><p>unification is actually not as hard as you might think</p></li>
<li><p>unless you do dynamic pattern unification, then it‚Äôs harder</p></li>
<li><p>but we can work our way up gradually</p></li>
<li><p>and work from the actual haskell source code that they provide</p></li>
</ul>
</section>
<section id="references" class="slide level2 unnumbered">
<h2 class="unnumbered">references</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-undecidable" class="csl-entry" role="doc-biblioentry">
Goldfarb, W. D. (1981). The undecidability of the second-order unification problem. <em>Theor. Comput. Sci.</em>, <em>13</em>, 225‚Äì230. <a href="https://www.sciencedirect.com/science/article/pii/0304397581900402">https://www.sciencedirect.com/science/article/pii/0304397581900402</a>
</div>
<div id="ref-tut" class="csl-entry" role="doc-biblioentry">
Gundry, A., &amp; McBride, C. (2013). <em>A tutorial implementation of dynamic pattern unification</em>. <a href="https://adam.gundry.co.uk/pub/pattern-unify/">https://adam.gundry.co.uk/pub/pattern-unify/</a>
</div>
<div id="ref-nipkow" class="csl-entry" role="doc-biblioentry">
Nipkow, T. (1993). Functional unification of higher-order patterns. <em>Eighth Annual Symposium on Logic in Computer Science (<span>LICS</span> ‚Äô93)</em>, 64‚Äì74. <a href="https://www21.in.tum.de/¬†nipkow/pubs/lics93.dvi.gz">https://www21.in.tum.de/¬†nipkow/pubs/lics93.dvi.gz</a>
</div>
<div id="ref-dcpl" class="csl-entry" role="doc-biblioentry">
Turbak, F., &amp; Gifford, D. (2008). <em>Design concepts in programming languages</em>. <span>MIT</span> Press. ISBN <a href="https://worldcat.org/isbn/978-0-262-20175-9">978-0-262-20175-9</a>
</div>
</div>
</section></section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  // reveal.js plugins
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/math/math.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
